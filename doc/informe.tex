\documentclass[a4paper,11pt]{article}
\title{\textbf{}}
\author{}	
\date{}

\usepackage[spanish]{babel} % espanol
\usepackage{graphicx} % graficos
\usepackage{listings} % para el codigo
\usepackage{vmargin} % margenes 

\begin{document}

\begin{titlepage}
\begin{center}

\vspace*{-1in}
\begin{figure}[htb]
\begin{center}
\includegraphics[width=4cm]{logo.png}
\end{center}
\end{figure}
	
\begin{huge}
\textbf{Universidad de Buenos Aires\\
Facultad de Ingenier\'ia \\}
\vspace*{0.2in}
\end{huge}

\begin{LARGE}
\textbf{66.20 Organizaci\'on de computadoras \\}
\vspace*{1in}
\end{LARGE}

\begin{LARGE}
\textbf{Trabajo pr\'actico 1:
Conjunto de \\instrucciones MIPS \\
%\vspace*{0.2in}
}
\end{LARGE}
\begin{LARGE}
\textbf{1$^{er}$ cuatrimestre de 2015} \\
\end{LARGE}

\vspace*{1in}

\begin{Large}
\begin{tabular}{ l l l }
   Paula Saffioti & Padr\'on: 92001 & Email: paula.saffioti@gmail.com \\
   Kaoru Heanna & Padr\'on: 91891 & Email: kaoru.heanna@gmail.com \\
   Juli\'an Scialabba & Padr\'on: 92181 & Email: julian.scialabba@gmail.com \\
 \end{tabular}\\
\end{Large}

\end{center}
\end{titlepage}

\section{Documentaci\'on}
El objetivo del trabajo pr\'actico es desarrollar una versi\'on del comando tac de UNIX utilizando el conjunto de instrucciones MIPS. 
Ya contab\'amos con el comando implementado en lenguaje C y deb\'iamos traducirlo a assembly MIPS. Para hacer esto optamos por dividir el c\'odigo en funciones peque\~nas, con el objetivo de poder implementarlas y testearlas independientemente.
El algoritmo base del programa que se resume en la siguiente lista de pasos:
\begin{enumerate}
	\item Abrir un archivo pasado por par\'ametro o recibir un stream de datos desde stdin.
	\item Leer el archivo o el stream l\'inea por l\'inea hasta el final y guardarlo en un array. El tama\~no de las l\'ineas debe ser din\'amico.
	\item Recorrer el array en sentido inverso imprimiendo por stdout el contenido de cada l\'inea.
	\item Cerrar el archivo si corresponde.
\end{enumerate}

El paso 1 fue implementado en C. Para el caso de los archivos lo resolvimos con la funci\'on fopen. Como resultado de este paso, nos qued\'o un puntero al archivo para operar con \'el. En caso de alg\'un error, lo lanzamos por stderr.

Los pasos 2 y 3 fueron realizados \'integramente en assembly MIPS. Para el manejo de la memoria din\'amica utilizamos las funciones ya implementadas mymalloc y myfree. Tuvimos que modificar el c\'odigo que utilizaba realloc para que tambi\'en pueda hacer uso de mymalloc.


El paso 4 para cerrar el archivo nuevamente fue implementado en C con la funci\'on fclose. 


El \'unico inconveniente durante el desarrollo de trabajo pr\'actico lo encontramos con la implementaci\'on de fgets. El problema era que haciamos la llamada al syscall encargado de la lectura de archivos (el 14) con los par\'ametros necesarios pero no nos devolv\'ia el bloque le\'ido. Tras mucho intentar, consultamos en el grupo de la materia esta cuesti\'on y al no obtener respuesta lo solucionamos llamando a fgets desde el c\'odigo assembly.

\section{Comandos}
Para obtener el ejecutable creamos un makefile. Por lo que para compilar el programa solo hace falta hacer:

\lstset{language=bash, breaklines=true, basicstyle=\normalsize}
\begin{lstlisting}
$ make
\end{lstlisting}

El makefile es el siguiente:
\begin{lstlisting}
PROG  = tp1
CFLAGS = -g -Wall
DSRC = src/
all: $(PROG)

deleteOld:
	rm $(PROG)

tp1: $(DSRC)main.c $(DSRC)printHelp.S $(DSRC)printVersion.S $(DSRC)isEndOfLine.S $(DSRC)strLength.S $(DSRC)concatBuffer.S $(DSRC)tacFile.S $(DSRC)printLines.S $(DSRC)resizeArrayLines.S  $(DSRC)mergeStrings.S $(DSRC)mymalloc.S $(DSRC)storeNewLine.S $(DSRC)readFile.S
	$(CC) $(CFLAGS) -o $@ $>

clean:
	rm -f $(PROG) *.so *.o *.a *.core
	
permissions:
	chmod +x $(PROG)

\end{lstlisting}


\section{Corridas de prueba}
Para corroborar el funcionamiento del programa cont\'abamos con una serie de archivos de prueba y con el diccionario de palabras ubicado en /usr/share/dict/words. 
\\
\\
\underline{Salidas de ejemplo:}\\
\textbf{return.txt:}\\
\emph{of -1 is returned and errno is set to indicate the error.
Upon successful completion a value of 0 is returned. Otherwise, a value}
\\\\
\textbf{basic.txt}\\
\emph{4. D\\
3. C\\
2. B\\
1. A\\}\\
\textbf{return.txt basic.txt}\\
\emph{of -1 is returned and errno is set to indicate the error.\\
Upon successful completion a value of 0 is returned. Otherwise, a value\\
4. D\\
3. C\\
2. B\\
1. A}\\

Para poder hacer todas las pruebas de manera r\'apida escribimos un script que compilaba el programa, luego lo ejecutaba para los archivos mencionados d\'andolos vuelta dos veces y finalmente verificaba que el archivo resultante fuera igual al original con md5sum. El script es el siguiente:
\lstset{language=bash, breaklines=true, basicstyle=\normalsize}
\begin{lstlisting}
#!/bin/bash

testFile() {
	echo -e "\nTEST "$1".txt"
	./tp0 test-files/$1.txt | ./tp0 > output/$1.txt
	res1=($(md5sum test-files/$1.txt))
	res2=($(md5sum output/$1.txt))
	
	echo "md5 de $1: $res2"
	if [ $res1 == $res2 ]; 
	then
		echo -e "OK\n"
	else
		echo -e "ERROR\n"
	fi
}

testWords() {
	echo -e "\nTEST WORDS"
	res1=($(cat '/usr/share/dict/words' | md5sum))
	res2=($(./tp0 '/usr/share/dict/words' | ./tp0 | md5sum))
	
	echo "md5 de words: $res2"
	if [ $res1 == $res2 ]; 
	then
		echo -e "OK\n"
	else
		echo -e "ERROR\n"
	fi
}

echo Compilando...
gcc -o tp0 main.c

FILES=(empty basic empty-lines large-file return status)

for i in ${FILES[@]}; do
	testFile ${i}
done

testWords
\end{lstlisting}
\underline{MD5 de los archivos de prueba procesados dos veces:}\\
\textbf{empty.txt:} d41d8cd98f00b204e9800998ecf8427e\\
\textbf{basic:} f82584604433de83165f0227f4f06c2c\\
\textbf{empty-lines.txt:} 0c060d8e86deedcb0f9cd89f6a3f9c93\\
\textbf{large-file.txt:} 8b2a59a337c384be9b640a38a377eef1\\
\textbf{return.txt:} 6777acdeb99f2fb0ed9e14fc82899e82\\
\textbf{status.txt:} 964ccaae773b2f9044dc549ed3636ab6\\
\textbf{words:} cbbcded3dc3b61ad50c4e36f79c37084

\section{C\'odigo fuente}

\lstset{language=C, breaklines=true, basicstyle=\normalsize}
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void printHelpInfo() {
    printf("%s", "Usage:\n");
    printf("%s", "	tp0 -h\n");
    printf("%s", "	tp0 -V\n");
    printf("%s", "	tp0 [file...]\n");
    printf("%s", "Options:\n");
    printf("%s", "	-V, --version Print version and quit.\n");
    printf("%s", "	-h, --help Print this information and quit.\n");
    printf("%s", "Examples:\n");
    printf("%s", "	tp0 foo.txt bar.txt\n");
    printf("%s", "	tp0 gz.txt\n");
}

void printVersionInfo() {
    printf("%s", "tp0 1.1\n");
    printf("%s", "Copyright © 2015 FIUBA.\n");
    printf("%s", "Esto es software libre: usted es libre de cambiarlo y redistribuirlo.\n");
    printf("%s", "No hay NINGUNA GARANTÍA, hasta donde permite la ley.\n");
    printf("%s", "\n");
    printf("%s", "Escrito por Julian Scialabba, Kaoru Heanna y Paula Saffioti.\n");
}

int isEndOfLine(char c) {
    if (c == '\n') {
        return 1;
    }
    return 0;
}

void concatBuffer(char** line, const char* buffer) {
    size_t len1 = *line ? strlen(*line) : 0;
    size_t len2 = buffer ? strlen(buffer) : 0;
    char* concat = realloc(*line, len1 + len2 + 1);
    if (concat) {
        memcpy(concat + len1, buffer, len2 + 1);
        *line = concat;
    }
}

int tacFile(FILE* fp) {
    const int bufIncrSize = 10;
    char ** arrayLines = NULL;
    int lineCounter = 0;
    char buffer[bufIncrSize];
    char* line = (char *) calloc(bufIncrSize, sizeof (char));
    while (fgets(buffer, bufIncrSize, fp)) {
        concatBuffer(&line, buffer);
        char lastCharacterBuffer = buffer[strlen(buffer) - 1];
        if (isEndOfLine(lastCharacterBuffer)) {
            arrayLines = realloc(arrayLines,
                    (lineCounter + 1) * sizeof (char *));
            arrayLines[lineCounter] = line;
            lineCounter++;
            line = (char *) calloc(bufIncrSize, sizeof (char));
        }
    }

    int i;
    for (i = lineCounter - 1; i >= 0; i--) {
        printf("%s", arrayLines[i]);
        free(arrayLines[i]);

    }
    free(line);
    free(arrayLines);
    return (EXIT_SUCCESS);
}

int main(int argc, char** argv) {

    if ((argc == 2) && ((strcmp(argv[1], "-h") == 0) || (strcmp(argv[1], "--help") == 0))) {
        printHelpInfo();
        return (EXIT_SUCCESS);
    }

    if ((argc == 2) && ((strcmp(argv[1], "-V") == 0) || (strcmp(argv[1], "--version") == 0))) {
        printVersionInfo();
        return (EXIT_SUCCESS);
    }

    int result;

    if (argc < 2) { //no tengo archivo de entrada, uso standard input
        result = tacFile(stdin);
        return (result);
    }

    int i;
    for (i = 1; i < argc; i++) {
        FILE *fp;
        fp = fopen(argv[i], "r");
        if (fp == NULL) {
            fprintf(stderr, "%s", argv[i]);
            fprintf(stderr, ": nombre de archivo o comando inválido.\n");
            return (EXIT_FAILURE);
        }
        tacFile(fp);
        fclose(fp);
    }
    return (EXIT_SUCCESS);
}

\end{lstlisting}

\section{C\'odigo MIPS32}
El c´odigo MIPS32 generado por el compilador;

\section{Enunciado}

\maketitle
\end{document}
